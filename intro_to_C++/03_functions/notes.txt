ğŸ”¹ What is std:: in C++?

std:: stands for Standard Namespace.
Itâ€™s just a prefix that tells the compiler:

â€œHey, Iâ€™m using something from the C++ Standard Library.â€

Examples:
std::cout   // console output
std::cin    // console input
std::string // string type
std::endl   // end line (flushes output buffer)
std::getline // reads full line of input

---

âœ… The Operators:

!. << â†’ Insertion Operator
	â€¢	Think: pushing data INTO the output stream
	â€¢	Like: â€œput this on the consoleâ€

std::cout << "Hello"; 
// Console << "Hello"

â€œTwo hands pushing TO the console.â€

2. >> â†’ Extraction Operator
	â€¢	Think: pulling data OUT OF the input stream
	â€¢	Like: â€œread this from the keyboardâ€

std::cin >> name; 
// name = Console >>

Mental Summary:

std::cout << "Message";
          ^^ push OUT to screen

std::cin >> variable;
          ^^ pull IN from user
          
---

ğŸ†š Difference from std::cin >>

ğŸ‘ std::cin >> name;
	â€¢	Only reads one word (stops at the first space)
	â€¢	Useful for: numbers, single-word input

âœ… std::getline(std::cin, name);
	â€¢	Reads the whole line, including spaces
	â€¢	Useful for: full names, sentences, commands like "attack with sword"

â¸»

ğŸ“¦ Syntax:

std::string name;
std::getline(std::cin, name);

ğŸ§  Common Confusion (Important)

If you use both std::cin >> and std::getline() together, youâ€™ll probably hit this problem:

std::string name;
int age;

std::cin >> age;
std::getline(std::cin, name); // â† this gets skipped!

Why? Because:
	â€¢	After std::cin >> age, the user hits Enter
	â€¢	That leftover newline \n is still in the input buffer
	â€¢	So getline() sees that newline and thinks: â€œOh, the line is done!â€

âœ… Fix it with std::cin.ignore():

std::cin >> age;
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
std::getline(std::cin, name); // â† now it works!

---

ğŸ”¹ extern
	â€¢	Means: â€œThis function exists in another fileâ€
	â€¢	Youâ€™re telling the compiler:
â€œDonâ€™t look for game_loop() in this file (main.cpp), just trust me â€” itâ€™s defined somewhere else during compilation.â€
	â€¢	Without extern, the compiler will complain:
â€œI donâ€™t know what game_loop is!â€

---

ğŸ”¹ void
	â€¢	This means the function does not return anything
	â€¢	It just performs actions like printing, changing data, etc.

    ğŸ”¹ (Player& player)
---

This part is super important and very C++-specific.

ğŸ”¸ Player:
	â€¢	This is the data type of the argument
	â€¢	It refers to your Player struct (defined in player.h)

ğŸ”¸ &:
	â€¢	This is a reference, meaning:
	â€¢	Youâ€™re not passing a copy of the player
	â€¢	Youâ€™re passing the original player, so changes inside game_loop() (like taking damage or leveling up) affect the real one

ğŸ”¸ player:
	â€¢	The name of the variable that will be used inside game_loop
---

ğŸ§± What is a struct in C++?

A struct (short for structure) is a custom data type that lets you group related variables together under one name.

ğŸ”¥ Bonus: Structs can even hold functions (methods)

struct Player {
    std::string name;
    int health;

    void printStatus() {
        std::cout << name << " has " << health << " HP.\n";
    }
};